{***************************************************************************}
{                                                                           }
{           Dext Framework                                                  }
{                                                                           }
{           Copyright (C) 2025 Cesar Romero & Dext Contributors             }
{                                                                           }
{           Licensed under the Apache License, Version 2.0 (the "License"); }
{           you may not use this file except in compliance with the License.}
{           You may obtain a copy of the License at                         }
{                                                                           }
{               http://www.apache.org/licenses/LICENSE-2.0                  }
{                                                                           }
{           Unless required by applicable law or agreed to in writing,      }
{           software distributed under the License is distributed on an     }
{           "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,    }
{           either express or implied. See the License for the specific     }
{           language governing permissions and limitations under the        }
{           License.                                                        }
{                                                                           }
{***************************************************************************}
{                                                                           }
{  Author:  Cesar Romero                                                    }
{  Created: 2025-12-08                                                      }
{                                                                           }
{***************************************************************************}
unit Dext.Threading.Async;

interface

uses
  System.SysUtils,
  System.Classes,
  System.Threading,
  System.TimeSpan,
  System.Rtti,
  System.TypInfo,
  Dext.Core.CancellationToken;

type
  /// <summary>
  ///   Interface identifying an Asynchronous Task generated by the Fluent API.
  ///   Inherits all standard capabilities from System.Threading.ITask.
  /// </summary>
  IAsyncTask = interface(ITask)
    ['{88997766-5544-3322-1100-AABBCCDDEE00}']
  end;

  /// <summary>
  ///   Generic class representing an asynchronous task with a result of type T.
  ///   Inherits directly from TTask to ensure full compatibility with the Delphi Parallel Library.
  ///   orchestrates the execution pipeline including chaining, cancellation, and main thread callbacks.
  /// </summary>
  /// <typeparam name="T">The type of the result produced by this task.</typeparam>
  TAsyncTask<T> = class(TTask, IAsyncTask)
  private
    FWork: TFunc<T>;
    FOnComplete: TProc<T>;
    FOnException: TProc<Exception>;
    FToken: ICancellationToken;
    FSyncComplete: Boolean;
    FSyncException: Boolean;
    
    procedure RunPipeline;
  public
    /// <summary>
    ///   Creates and initializes the async task.
    ///   Note: call Start to begin execution.
    /// </summary>
    constructor Create(const AWork: TFunc<T>; 
      const OnComplete: TProc<T>; 
      const OnException: TProc<Exception>; 
      const AToken: ICancellationToken = nil;
      const SyncComplete: Boolean = True;
      const SyncException: Boolean = True);
    destructor Destroy; override;
  end;

  /// <summary>
  ///   Fluent Builder record for configuring an asynchronous operation pipeline.
  ///   Allows chaining steps, setting callbacks, and handling cancellation before starting execution.
  /// </summary>
  /// <typeparam name="T">The type of the result passed through the current stage of the pipeline.</typeparam>
  TAsyncBuilder<T> = record
  private
    FWork: TFunc<T>;
    FOnComplete: TProc<T>;
    FOnException: TProc<Exception>;
    FToken: ICancellationToken;
    FSyncComplete: Boolean;
    FSyncException: Boolean;
  public
    /// <summary>
    ///   Initializes the builder with the initial unit of work.
    /// </summary>
    constructor Create(const AWork: TFunc<T>; const AToken: ICancellationToken = nil);

    /// <summary>
    ///   Chains a new function to be executed after the current work is successfully completed.
    ///   The result of the previous step is passed as input to this new function.
    /// </summary>
    /// <typeparam name="U">The result type of the new function.</typeparam>
    function ThenBy<U>(const AFunc: TFunc<T, U>): TAsyncBuilder<U>; overload;

    /// <summary>
    ///   Chains a procedure (side-effect) to be executed after the current work.
    ///   The result of the previous step is passed as input, and the pipeline continues with the same result type T.
    /// </summary>
    function ThenBy(const AProc: TProc<T>): TAsyncBuilder<T>; overload;

    /// <summary>
    ///   Sets a callback to be executed on the Main Thread upon successful completion of the entire pipeline.
    /// </summary>
    function OnComplete(const AProc: TProc<T>): TAsyncBuilder<T>;

    /// <summary>
    ///   Sets a callback to be executed on the Background Thread (same as the task) upon successful completion.
    ///   Use this for non-UI tasks to avoid context switching costs.
    /// </summary>
    function OnCompleteAsync(const AProc: TProc<T>): TAsyncBuilder<T>;

    /// <summary>
    ///   Sets a callback to be executed on the Main Thread if an exception occurs at any point in the pipeline.
    ///   Also handles OperationCancelled exceptions.
    /// </summary>
    function OnException(const AProc: TProc<Exception>): TAsyncBuilder<T>;

    /// <summary>
    ///   Sets a callback to be executed on the Background Thread if an exception occurs.
    ///   Use this for logging or background cleanup to avoid context switching costs.
    /// </summary>
    function OnExceptionAsync(const AProc: TProc<Exception>): TAsyncBuilder<T>;

    /// <summary>
    ///   Associates a CancellationToken with this task.
    ///   The task will check for cancellation requests before starting and between pipeline steps.
    /// </summary>
    function WithCancellation(const AToken: ICancellationToken): TAsyncBuilder<T>;

    /// <summary>
    ///   Finalizes the configuration, creates the TAsyncTask, and immediately starts it in the ThreadPool.
    /// </summary>
    /// <returns>An interface to the running task.</returns>
    function Start: IAsyncTask;
  end;

  /// <summary>
  ///   Static entry point for creating Asynchronous Tasks.
  /// </summary>
  TAsyncTask = record
  public
    /// <summary>
    ///   Starts defining an async task that returns a value of type T.
    /// </summary>
    class function Run<T>(const AFunc: TFunc<T>): TAsyncBuilder<T>; overload; static;

    /// <summary>
    ///   Starts defining an async task that performs an action (procedure) and returns Boolean (True).
    /// </summary>
    class function Run(const AProc: TProc): TAsyncBuilder<Boolean>; overload; static;
  end;

implementation

{ TAsyncTask<T> }

constructor TAsyncTask<T>.Create(const AWork: TFunc<T>; 
  const OnComplete: TProc<T>; 
  const OnException: TProc<Exception>; 
  const AToken: ICancellationToken;
  const SyncComplete: Boolean;
  const SyncException: Boolean);
begin
  // Initialize internal state
  FWork := AWork;
  FOnComplete := OnComplete;
  FOnException := OnException;
  FToken := AToken;
  FSyncComplete := SyncComplete;
  FSyncException := SyncException;
  
  // Call the protected TTask constructor to ensure proper initialization with the Default ThreadPool.
  // We wrap our RunPipeline logic in a simple anonymous procedure.
  inherited Create(
    nil,                    // Sender
    nil,                    // Event
    procedure
    begin
      RunPipeline;
    end,                    // AProc
    TThreadPool.Default,    // APool (Explicitly pass Default)
    nil,                    // AParent
    [],                     // CreateFlags
    nil                     // AParentControlFlag
  );
end;

destructor TAsyncTask<T>.Destroy;
begin
  inherited;
end;

procedure TAsyncTask<T>.RunPipeline;
var
  Res: T;
  LOnComplete: TProc<T>;
  LOnException: TProc<Exception>;
  CapturedException: TObject;
begin
  try
    try
      // 1. Check for Cancellation (Native Task Status)
      if GetStatus = TTaskStatus.Canceled then Exit;

      // 2. Check for Cancellation (Token) - Before execution
      if (FToken <> nil) and (FToken.IsCancellationRequested) then
        FToken.ThrowIfCancellationRequested;

      // 3. Execute the Work Pipeline
      Res := Default(T);
      if Assigned(FWork) then
        Res := FWork();

      // 4. Check for Cancellation (Token) - After execution (before callbacks)
      if (FToken <> nil) and (FToken.IsCancellationRequested) then
        FToken.ThrowIfCancellationRequested;

      // 5. Execute Success Callback
      LOnComplete := FOnComplete;
      if Assigned(LOnComplete) then
      begin
        if FSyncComplete then
        begin
          // Compiler captures "Res" (type T) automatically for the closure.
          TThread.Queue(nil,
            procedure
            begin
              LOnComplete(Res);
            end);
        end
        else
        begin
          LOnComplete(Res);
        end;
      end;

    except
      on E: Exception do
      begin
        // 6. Handle Exceptions and Cancellation
        LOnException := FOnException;

        if Assigned(LOnException) then
        begin
          if FSyncException then
          begin
            // "Steal" exception ownership from RTL
            CapturedException := AcquireExceptionObject;
            
            TThread.Queue(nil,
              procedure
              begin
                try
                  if CapturedException is Exception then
                    LOnException(Exception(CapturedException));
                finally
                  CapturedException.Free;
                end;
              end);
          end
          else
          begin
            // Async: Current thread still owns exception
            LOnException(E);
          end;
        end;
      end;
    end;
  except
    // Catch-all to prevent exceptions from crashing the thread pool worker
  end;
end;

{ TAsyncBuilder<T> }

constructor TAsyncBuilder<T>.Create(const AWork: TFunc<T>; const AToken: ICancellationToken);
begin
  FWork := AWork;
  FOnComplete := nil;
  FOnException := nil;
  FToken := AToken;
  FSyncComplete := True;
  FSyncException := True;
end;

function TAsyncBuilder<T>.ThenBy<U>(const AFunc: TFunc<T, U>): TAsyncBuilder<U>;
var
  LPrevious: TFunc<T>;
begin
  LPrevious := FWork;
  // Create a new builder for the next step, preserving the CancellationToken
  Result := TAsyncBuilder<U>.Create(
    function: U
    begin
      var Input := LPrevious();
      Result := AFunc(Input);
    end,
    FToken
  );
end;

function TAsyncBuilder<T>.ThenBy(const AProc: TProc<T>): TAsyncBuilder<T>;
var
  LPrevious: TFunc<T>;
begin
  LPrevious := FWork;
  // Create a new builder, preserving the CancellationToken
  Result := TAsyncBuilder<T>.Create(
    function: T
    begin
      Result := LPrevious();
      AProc(Result);
    end,
    FToken
  );
end;

function TAsyncBuilder<T>.OnComplete(const AProc: TProc<T>): TAsyncBuilder<T>;
begin
  FOnComplete := AProc;
  FSyncComplete := True;
  Result := Self;
end;

function TAsyncBuilder<T>.OnCompleteAsync(const AProc: TProc<T>): TAsyncBuilder<T>;
begin
  FOnComplete := AProc;
  FSyncComplete := False;
  Result := Self;
end;

function TAsyncBuilder<T>.OnException(const AProc: TProc<Exception>): TAsyncBuilder<T>;
begin
  FOnException := AProc;
  FSyncException := True;
  Result := Self;
end;

function TAsyncBuilder<T>.OnExceptionAsync(const AProc: TProc<Exception>): TAsyncBuilder<T>;
begin
  FOnException := AProc;
  FSyncException := False;
  Result := Self;
end;

function TAsyncBuilder<T>.WithCancellation(const AToken: ICancellationToken): TAsyncBuilder<T>;
begin
  FToken := AToken;
  Result := Self;
end;

function TAsyncBuilder<T>.Start: IAsyncTask;
begin
  // Create the specific TAsyncTask instance
  var Task := TAsyncTask<T>.Create(FWork, FOnComplete, FOnException, FToken, FSyncComplete, FSyncException);
  // Start execution in the ThreadPool
  Task.Start;
  Result := Task;
end;

{ TAsyncTask }

class function TAsyncTask.Run<T>(const AFunc: TFunc<T>): TAsyncBuilder<T>;
begin
  Result := TAsyncBuilder<T>.Create(AFunc, nil);
end;

class function TAsyncTask.Run(const AProc: TProc): TAsyncBuilder<Boolean>;
begin
  // Wrap procedure in a function that returns True
  Result := TAsyncBuilder<Boolean>.Create(
    function: Boolean
    begin
      AProc();
      Result := True;
    end, 
    nil
  );
end;

end.

