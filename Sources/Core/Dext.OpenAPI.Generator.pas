unit Dext.OpenAPI.Generator;

interface

uses
  System.SysUtils,
  System.Generics.Collections,
  System.Rtti,
  System.TypInfo,
  Dext.OpenAPI.Types,
  Dext.Http.Interfaces,
  Dext.Json;

type
  /// <summary>
  ///   Configuration options for OpenAPI document generation.
  /// </summary>
  TOpenAPIOptions = record
    Title: string;
    Description: string;
    Version: string;
    ServerUrl: string;
    ServerDescription: string;
    ContactName: string;
    ContactEmail: string;
    LicenseName: string;
    LicenseUrl: string;
    
    class function Default: TOpenAPIOptions; static;
  end;

  /// <summary>
  ///   Generates OpenAPI 3.0 documentation from endpoint metadata.
  /// </summary>
  TOpenAPIGenerator = class
  private
    FOptions: TOpenAPIOptions;
    FSchemaCache: TDictionary<PTypeInfo, TOpenAPISchema>;
    
    function CreateInfoSection: TOpenAPIInfo;
    function CreateServerSection: TOpenAPIServer;
    function CreatePathItem(const AMetadata: TEndpointMetadata): TOpenAPIPathItem;
    function CreateOperation(const AMetadata: TEndpointMetadata): TOpenAPIOperation;
    function GetOperationId(const AMethod, APath: string): string;
    
    /// <summary>
    ///   Converts a Delphi RTTI type to an OpenAPI schema.
    /// </summary>
    function TypeToSchema(ATypeInfo: PTypeInfo): TOpenAPISchema;
    
    /// <summary>
    ///   Extracts path parameters from a route pattern (e.g., /users/{id}).
    /// </summary>
    function ExtractPathParameters(const APath: string): TArray<string>;
    
  public
    constructor Create(const AOptions: TOpenAPIOptions);
    destructor Destroy; override;
    
    /// <summary>
    ///   Generates a complete OpenAPI document from endpoint metadata.
    /// </summary>
    function Generate(const AEndpoints: TArray<TEndpointMetadata>): TOpenAPIDocument;
    
    /// <summary>
    ///   Generates OpenAPI JSON string from endpoint metadata.
    /// </summary>
    function GenerateJson(const AEndpoints: TArray<TEndpointMetadata>): string;
  end;

implementation

uses
  JsonDataObjects,
  System.RegularExpressions,
  System.StrUtils;

{ TOpenAPIOptions }

class function TOpenAPIOptions.Default: TOpenAPIOptions;
begin
  Result.Title := 'Dext API';
  Result.Description := 'API documentation generated by Dext Framework';
  Result.Version := '1.0.0';
  Result.ServerUrl := 'http://localhost:8080';
  Result.ServerDescription := 'Development server';
  Result.ContactName := '';
  Result.ContactEmail := '';
  Result.LicenseName := 'MIT';
  Result.LicenseUrl := 'https://opensource.org/licenses/MIT';
end;

{ TOpenAPIGenerator }

constructor TOpenAPIGenerator.Create(const AOptions: TOpenAPIOptions);
begin
  inherited Create;
  FOptions := AOptions;
  FSchemaCache := TDictionary<PTypeInfo, TOpenAPISchema>.Create;
end;

destructor TOpenAPIGenerator.Destroy;
var
  Schema: TOpenAPISchema;
begin
  for Schema in FSchemaCache.Values do
    Schema.Free;
  FSchemaCache.Free;
  inherited;
end;

function TOpenAPIGenerator.CreateInfoSection: TOpenAPIInfo;
begin
  Result := TOpenAPIInfo.Create;
  Result.Title := FOptions.Title;
  Result.Description := FOptions.Description;
  Result.Version := FOptions.Version;
  
  if FOptions.ContactName <> '' then
  begin
    Result.Contact := TOpenAPIContact.Create;
    Result.Contact.Name := FOptions.ContactName;
    Result.Contact.Email := FOptions.ContactEmail;
  end;
  
  if FOptions.LicenseName <> '' then
  begin
    Result.License := TOpenAPILicense.Create;
    Result.License.Name := FOptions.LicenseName;
    Result.License.Url := FOptions.LicenseUrl;
  end;
end;

function TOpenAPIGenerator.CreateServerSection: TOpenAPIServer;
begin
  Result := TOpenAPIServer.Create;
  Result.Url := FOptions.ServerUrl;
  Result.Description := FOptions.ServerDescription;
end;

function TOpenAPIGenerator.GetOperationId(const AMethod, APath: string): string;
var
  CleanPath: string;
begin
  // Convert /users/{id} to getUsersById
  CleanPath := APath.Replace('/', '_').Replace('{', '').Replace('}', '');
  if CleanPath.StartsWith('_') then
    CleanPath := CleanPath.Substring(1);
  Result := AMethod.ToLower + CleanPath;
end;

function TOpenAPIGenerator.ExtractPathParameters(const APath: string): TArray<string>;
var
  Matches: TMatchCollection;
  I: Integer;
begin
  var Regex := TRegEx.Create('\{([^}]+)\}');
  Matches := Regex.Matches(APath);
  
  SetLength(Result, Matches.Count);
  for I := 0 to Matches.Count - 1 do
    Result[I] := Matches[I].Groups[1].Value;
end;

function TOpenAPIGenerator.TypeToSchema(ATypeInfo: PTypeInfo): TOpenAPISchema;
begin
  if FSchemaCache.ContainsKey(ATypeInfo) then
    Exit(FSchemaCache[ATypeInfo]);
    
  Result := TOpenAPISchema.Create;
  
  case ATypeInfo.Kind of
    tkInteger, tkInt64:
    begin
      Result.DataType := odtInteger;
      Result.Format := 'int64';
    end;
    
    tkFloat:
    begin
      Result.DataType := odtNumber;
      Result.Format := 'double';
    end;
    
    tkString, tkLString, tkWString, tkUString:
    begin
      Result.DataType := odtString;
    end;
    
    tkEnumeration:
    begin
      if ATypeInfo = TypeInfo(Boolean) then
        Result.DataType := odtBoolean
      else
      begin
        Result.DataType := odtString;
        // TODO: Add enum values
      end;
    end;
    
    tkRecord, tkClass:
    begin
      Result.DataType := odtObject;
      // TODO: Introspect record/class fields using RTTI
      var RttiContext := TRttiContext.Create;
      try
        var RttiType := RttiContext.GetType(ATypeInfo);
        if Assigned(RttiType) then
        begin
          for var Field in RttiType.GetFields do
          begin
            if Field.Visibility in [mvPublic, mvPublished] then
            begin
              var FieldSchema := TypeToSchema(Field.FieldType.Handle);
              Result.Properties.Add(Field.Name, FieldSchema);
            end;
          end;
        end;
      finally
        RttiContext.Free;
      end;
    end;
    
    tkDynArray:
    begin
      Result.DataType := odtArray;
      // TODO: Determine array element type
    end;
  end;
  
  FSchemaCache.Add(ATypeInfo, Result);
end;

function TOpenAPIGenerator.CreateOperation(const AMetadata: TEndpointMetadata): TOpenAPIOperation;
var
  PathParams: TArray<string>;
  ParamName: string;
  Param: TOpenAPIParameter;
  Response: TOpenAPIResponse;
begin
  Result := TOpenAPIOperation.Create;
  Result.Summary := AMetadata.Summary;
  Result.Description := AMetadata.Description;
  Result.OperationId := GetOperationId(AMetadata.Method, AMetadata.Path);
  Result.Tags := AMetadata.Tags;
  
  // Extract path parameters
  PathParams := ExtractPathParameters(AMetadata.Path);
  for ParamName in PathParams do
  begin
    Param := TOpenAPIParameter.Create;
    Param.Name := ParamName;
    Param.Location := oplPath;
    Param.Required := True;
    Param.Schema.DataType := odtString; // Default to string
    Result.Parameters.Add(Param);
  end;
  
  // Add request body for POST/PUT/PATCH
  if AMetadata.Method.ToUpper.Equals('POST') or 
     AMetadata.Method.ToUpper.Equals('PUT') or 
     AMetadata.Method.ToUpper.Equals('PATCH') then
  begin
    Result.RequestBody := TOpenAPIRequestBody.Create;
    Result.RequestBody.Required := True;
    
    var Schema := TOpenAPISchema.Create;
    Schema.DataType := odtObject;
    Result.RequestBody.Content.Add('application/json', Schema);
  end;
  
  // Add default responses
  Response := TOpenAPIResponse.Create;
  Response.Description := 'Successful response';
  
  var ResponseSchema := TOpenAPISchema.Create;
  ResponseSchema.DataType := odtObject;
  Response.Content.Add('application/json', ResponseSchema);
  
  Result.Responses.Add('200', Response);
end;

function TOpenAPIGenerator.CreatePathItem(const AMetadata: TEndpointMetadata): TOpenAPIPathItem;
var
  Operation: TOpenAPIOperation;
begin
  Result := TOpenAPIPathItem.Create;
  Operation := CreateOperation(AMetadata);
  
  case IndexStr(AMetadata.Method.ToUpper, ['GET', 'POST', 'PUT', 'DELETE', 'PATCH']) of
    0: Result.Get := Operation;
    1: Result.Post := Operation;
    2: Result.Put := Operation;
    3: Result.Delete := Operation;
    4: Result.Patch := Operation;
  else
    Operation.Free;
  end;
end;

function TOpenAPIGenerator.Generate(const AEndpoints: TArray<TEndpointMetadata>): TOpenAPIDocument;
var
  Metadata: TEndpointMetadata;
  PathItem: TOpenAPIPathItem;
  ExistingPathItem: TOpenAPIPathItem;
  Operation: TOpenAPIOperation;
begin
  Result := TOpenAPIDocument.Create;
  Result.Info := CreateInfoSection;
  Result.Servers.Add(CreateServerSection);
  
  for Metadata in AEndpoints do
  begin
    // Check if path already exists (multiple methods on same path)
    if Result.Paths.TryGetValue(Metadata.Path, ExistingPathItem) then
    begin
      // Add operation to existing path item
      Operation := CreateOperation(Metadata);
      case IndexStr(Metadata.Method.ToUpper, ['GET', 'POST', 'PUT', 'DELETE', 'PATCH']) of
        0: ExistingPathItem.Get := Operation;
        1: ExistingPathItem.Post := Operation;
        2: ExistingPathItem.Put := Operation;
        3: ExistingPathItem.Delete := Operation;
        4: ExistingPathItem.Patch := Operation;
      else
        Operation.Free;
      end;
    end
    else
    begin
      // Create new path item
      PathItem := CreatePathItem(Metadata);
      Result.Paths.Add(Metadata.Path, PathItem);
    end;
  end;
end;

function TOpenAPIGenerator.GenerateJson(const AEndpoints: TArray<TEndpointMetadata>): string;
var
  Doc: TOpenAPIDocument;
  Json: TJsonObject;
  PathsJson: TJsonObject;
  PathItem: TOpenAPIPathItem;
  PathItemJson: TJsonObject;
  OperationJson: TJsonObject;
  ServersArray: TJsonArray;
  Server: TOpenAPIServer;
  ServerJson: TJsonObject;
  InfoJson: TJsonObject;
  ParamsArray: TJsonArray;
  ParamJson: TJsonObject;
  ResponsesJson: TJsonObject;
  Response: TOpenAPIResponse;
  ResponseJson: TJsonObject;
  ContentJson: TJsonObject;
  SchemaJson: TJsonObject;
  Schema: TOpenAPISchema;
  Pair: TPair<string, TOpenAPIPathItem>;
  TagsArray: TJsonArray;
begin
  Doc := Generate(AEndpoints);
  try
    Json := TJsonObject.Create;
    try
      Json.S['openapi'] := Doc.OpenAPI;
      
      // Info section
      InfoJson := TJsonObject.Create;
      InfoJson.S['title'] := Doc.Info.Title;
      InfoJson.S['description'] := Doc.Info.Description;
      InfoJson.S['version'] := Doc.Info.Version;
      
      if Assigned(Doc.Info.Contact) then
      begin
        var ContactJson := TJsonObject.Create;
        if Doc.Info.Contact.Name <> '' then
          ContactJson.S['name'] := Doc.Info.Contact.Name;
        if Doc.Info.Contact.Email <> '' then
          ContactJson.S['email'] := Doc.Info.Contact.Email;
        InfoJson.O['contact'] := ContactJson;
      end;
      
      if Assigned(Doc.Info.License) then
      begin
        var LicenseJson := TJsonObject.Create;
        LicenseJson.S['name'] := Doc.Info.License.Name;
        if Doc.Info.License.Url <> '' then
          LicenseJson.S['url'] := Doc.Info.License.Url;
        InfoJson.O['license'] := LicenseJson;
      end;
      
      Json.O['info'] := InfoJson;
      
      // Servers section
      ServersArray := TJsonArray.Create;
      for Server in Doc.Servers do
      begin
        ServerJson := TJsonObject.Create;
        ServerJson.S['url'] := Server.Url;
        ServerJson.S['description'] := Server.Description;
        ServersArray.Add(ServerJson);
      end;
      Json.A['servers'] := ServersArray;
      
      // Paths section
      PathsJson := TJsonObject.Create;
      for Pair in Doc.Paths do
      begin
        PathItem := Pair.Value;
        PathItemJson := TJsonObject.Create;
        
        // Helper function to add operation
        var AddOperation := procedure(Op: TOpenAPIOperation; const MethodName: string)
        begin
          if not Assigned(Op) then Exit;
          
          OperationJson := TJsonObject.Create;
          if Op.Summary <> '' then
            OperationJson.S['summary'] := Op.Summary;
          if Op.Description <> '' then
            OperationJson.S['description'] := Op.Description;
          OperationJson.S['operationId'] := Op.OperationId;
          
          // Tags
          if Length(Op.Tags) > 0 then
          begin
            TagsArray := TJsonArray.Create;
            for var Tag in Op.Tags do
              TagsArray.Add(Tag);
            OperationJson.A['tags'] := TagsArray;
          end;
          
          // Parameters
          if Op.Parameters.Count > 0 then
          begin
            ParamsArray := TJsonArray.Create;
            for var Param in Op.Parameters do
            begin
              ParamJson := TJsonObject.Create;
              ParamJson.S['name'] := Param.Name;
              
              case Param.Location of
                oplQuery: ParamJson.S['in'] := 'query';
                oplPath: ParamJson.S['in'] := 'path';
                oplHeader: ParamJson.S['in'] := 'header';
                oplCookie: ParamJson.S['in'] := 'cookie';
              end;
              
              ParamJson.B['required'] := Param.Required;
              
              if Param.Description <> '' then
                ParamJson.S['description'] := Param.Description;
              
              // Schema
              SchemaJson := TJsonObject.Create;
              case Param.Schema.DataType of
                odtString: SchemaJson.S['type'] := 'string';
                odtNumber: SchemaJson.S['type'] := 'number';
                odtInteger: SchemaJson.S['type'] := 'integer';
                odtBoolean: SchemaJson.S['type'] := 'boolean';
                odtArray: SchemaJson.S['type'] := 'array';
                odtObject: SchemaJson.S['type'] := 'object';
              end;
              
              if Param.Schema.Format <> '' then
                SchemaJson.S['format'] := Param.Schema.Format;
              
              ParamJson.O['schema'] := SchemaJson;
              ParamsArray.Add(ParamJson);
            end;
            OperationJson.A['parameters'] := ParamsArray;
          end;
          
          // Request Body
          if Assigned(Op.RequestBody) then
          begin
            var RequestBodyJson := TJsonObject.Create;
            RequestBodyJson.B['required'] := Op.RequestBody.Required;
            
            ContentJson := TJsonObject.Create;
            for var SchemaPair in Op.RequestBody.Content do
            begin
              Schema := SchemaPair.Value;
              SchemaJson := TJsonObject.Create;
              
              case Schema.DataType of
                odtString: SchemaJson.S['type'] := 'string';
                odtNumber: SchemaJson.S['type'] := 'number';
                odtInteger: SchemaJson.S['type'] := 'integer';
                odtBoolean: SchemaJson.S['type'] := 'boolean';
                odtArray: SchemaJson.S['type'] := 'array';
                odtObject: SchemaJson.S['type'] := 'object';
              end;
              
              ContentJson.O[SchemaPair.Key] := SchemaJson;
            end;
            
            RequestBodyJson.O['content'] := ContentJson;
            OperationJson.O['requestBody'] := RequestBodyJson;
          end;
          
          // Responses
          ResponsesJson := TJsonObject.Create;
          for var ResponsePair in Op.Responses do
          begin
            Response := ResponsePair.Value;
            ResponseJson := TJsonObject.Create;
            ResponseJson.S['description'] := Response.Description;
            
            if Response.Content.Count > 0 then
            begin
              ContentJson := TJsonObject.Create;
              for var SchemaPair in Response.Content do
              begin
                Schema := SchemaPair.Value;
                SchemaJson := TJsonObject.Create;
                
                case Schema.DataType of
                  odtString: SchemaJson.S['type'] := 'string';
                  odtNumber: SchemaJson.S['type'] := 'number';
                  odtInteger: SchemaJson.S['type'] := 'integer';
                  odtBoolean: SchemaJson.S['type'] := 'boolean';
                  odtArray: SchemaJson.S['type'] := 'array';
                  odtObject: SchemaJson.S['type'] := 'object';
                end;
                
                ContentJson.O[SchemaPair.Key] := SchemaJson;
              end;
              ResponseJson.O['content'] := ContentJson;
            end;
            
            ResponsesJson.O[ResponsePair.Key] := ResponseJson;
          end;
          OperationJson.O['responses'] := ResponsesJson;
          
          PathItemJson.O[MethodName] := OperationJson;
        end;
        
        AddOperation(PathItem.Get, 'get');
        AddOperation(PathItem.Post, 'post');
        AddOperation(PathItem.Put, 'put');
        AddOperation(PathItem.Delete, 'delete');
        AddOperation(PathItem.Patch, 'patch');
        
        PathsJson.O[Pair.Key] := PathItemJson;
      end;
      Json.O['paths'] := PathsJson;
      
      Result := Json.ToJSON(True);
    finally
      Json.Free;
    end;
  finally
    Doc.Free;
  end;
end;

end.
