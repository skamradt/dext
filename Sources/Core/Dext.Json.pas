{***************************************************************************}
{                                                                           }
{           Dext Framework                                                  }
{                                                                           }
{           Copyright (C) 2025 Cesar Romero & Dext Contributors             }
{                                                                           }
{           Licensed under the Apache License, Version 2.0 (the "License"); }
{           you may not use this file except in compliance with the License.}
{           You may obtain a copy of the License at                         }
{                                                                           }
{               http://www.apache.org/licenses/LICENSE-2.0                  }
{                                                                           }
{           Unless required by applicable law or agreed to in writing,      }
{           software distributed under the License is distributed on an     }
{           "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,    }
{           either express or implied. See the License for the specific     }
{           language governing permissions and limitations under the        }
{           License.                                                        }
{                                                                           }
{***************************************************************************}
{                                                                           }
{  Author:  Cesar Romero                                                    }
{  Created: 2025-12-08                                                      }
{                                                                           }
{***************************************************************************}
unit Dext.Json;

interface

uses
  System.Character,
  System.Generics.Collections,
  System.Rtti,
  System.SysUtils,
  System.TypInfo,
  Dext.Types.UUID,
  Dext.Json.Types;

type
  /// <summary>
  ///   Exception raised for errors during JSON serialization or deserialization.
  /// </summary>
  EDextJsonException = class(Exception);

  /// <summary>
  ///   Base class for all Dext JSON attributes.
  /// </summary>
  DextJsonAttribute = class abstract(TCustomAttribute)
  end;

  /// <summary>
  ///   Specifies a custom name for a field in the JSON output.
  /// </summary>
  JsonNameAttribute = class(DextJsonAttribute)
  private
    FName: string;
  public
    /// <summary>
    ///   Initializes a new instance of the JsonNameAttribute class.
    /// </summary>
    /// <param name="AName">
    ///   The custom name to be used in the JSON.
    /// </param>
    constructor Create(const AName: string);
    property Name: string read FName;
  end;

  /// <summary>
  ///   Indicates that a field should be ignored during serialization and deserialization.
  /// </summary>
  JsonIgnoreAttribute = class(DextJsonAttribute);

  /// <summary>
  ///   Specifies a custom format string for date/time fields.
  /// </summary>
  JsonFormatAttribute = class(DextJsonAttribute)
  private
    FFormat: string;
  public
    /// <summary>
    ///   Initializes a new instance of the JsonFormatAttribute class.
    /// </summary>
    /// <param name="AFormat">
    ///   The format string (e.g., 'yyyy-mm-dd').
    /// </param>
    constructor Create(const AFormat: string);
    property Format: string read FFormat;
  end;
  
  /// <summary>
  ///   Forces a numeric field to be serialized as a string.
  /// </summary>
  JsonStringAttribute = class(DextJsonAttribute);

  /// <summary>
  ///   Forces a string field to be serialized as a number (if possible).
  /// </summary>
  JsonNumberAttribute = class(DextJsonAttribute);

  /// <summary>
  ///   Forces a field to be serialized as a boolean.
  /// </summary>
  JsonBooleanAttribute = class(DextJsonAttribute);

  /// <summary>
  ///   Defines the casing style for JSON property names.
  /// </summary>
  TDextCaseStyle = (
    /// <summary>Keep names as they are in the record/class.</summary>
    Unchanged, 
    /// <summary>Convert to camelCase (e.g., myProperty).</summary>
    CamelCase, 
    /// <summary>Convert to PascalCase (e.g., MyProperty).</summary>
    PascalCase, 
    /// <summary>Convert to snake_case (e.g., my_property).</summary>
    SnakeCase
  );

  /// <summary>
  ///   Defines how enumerations are serialized.
  /// </summary>
  TDextEnumStyle = (
    /// <summary>Serialize as the underlying integer value.</summary>
    AsNumber, 
    /// <summary>Serialize as the string name of the enum value.</summary>
    AsString
  );

  /// <summary>
  ///   Defines JSON output formatting.
  /// </summary>
  TDextFormatting = (
    /// <summary>Compact JSON (no whitespace).</summary>
    None, 
    /// <summary>Indented JSON for readability.</summary>
    Indented
  );

  /// <summary>
  ///   Defines standard date/time formats.
  /// </summary>
  TDextDateFormat = (
    /// <summary>ISO 8601 format (e.g., "2025-11-16T11:07:37.565").</summary>
    ISO8601,        
    /// <summary>Unix timestamp (seconds since epoch).</summary>
    UnixTimestamp,  
    /// <summary>Custom format string.</summary>
    CustomFormat    
  );

  /// <summary>
  ///   Utilities for JSON manipulation, including casing.
  /// </summary>
  TJsonUtils = record
  public
    class function ToCamelCase(const S: string): string; static;
    class function ToPascalCase(const S: string): string; static;
    class function ToSnakeCase(const S: string): string; static;
    class function ApplyCaseStyle(const S: string; Style: TDextCaseStyle): string; static;
  end;

  /// <summary>
  ///   Configuration settings for the JSON serializer.
  /// </summary>
  TDextSettings = record
  public
    Formatting: TDextFormatting;
    IgnoreDefaultValues: Boolean;
    IgnoreNullValues: Boolean;
    DateFormat: string;
    CaseStyle: TDextCaseStyle;
    EnumStyle: TDextEnumStyle;
    CaseInsensitive: Boolean;
    DateFormatStyle: TDextDateFormat;
    
    /// <summary>
    ///   Returns the default settings.
    /// </summary>
    class function Default: TDextSettings; static;
    
    /// <summary>
    ///   Returns settings configured for indented output.
    /// </summary>
    class function Indented: TDextSettings; static;
    
    /// <summary>
    ///   Returns a new settings instance with CamelCase enabled.
    /// </summary>
    function WithCamelCase: TDextSettings;
    
    /// <summary>
    ///   Returns a new settings instance with PascalCase enabled.
    /// </summary>
    function WithPascalCase: TDextSettings;
    
    /// <summary>
    ///   Returns a new settings instance with SnakeCase enabled.
    /// </summary>
    function WithSnakeCase: TDextSettings;
    
    /// <summary>
    ///   Returns a new settings instance with Enums serialized as strings.
    /// </summary>
    function WithEnumAsString: TDextSettings;
    
    /// <summary>
    ///   Returns a new settings instance with Enums serialized as numbers.
    /// </summary>
    function WithEnumAsNumber: TDextSettings;
    
    /// <summary>
    ///   Returns a new settings instance that ignores null values during serialization.
    /// </summary>
    function WithIgnoreNullValues: TDextSettings;
    
    /// <summary>
    ///   Returns a new settings instance with case-insensitive property matching.
    /// </summary>
    function WithCaseInsensitive: TDextSettings;
    
    /// <summary>
    ///   Returns a new settings instance using ISO 8601 date format.
    /// </summary>
    function WithISODateFormat: TDextSettings;
    
    /// <summary>
    ///   Returns a new settings instance using Unix Timestamp date format.
    /// </summary>
    function WithUnixTimestamp: TDextSettings;
    
    /// <summary>
    ///   Returns a new settings instance using a custom date format.
    /// </summary>
    function WithCustomDateFormat(const Format: string): TDextSettings;
  end;

  /// <summary>
  ///   Main entry point for JSON serialization and deserialization.
  /// </summary>
  TDextJson = class
  private
    class var FProvider: IDextJsonProvider;
    class var FDefaultSettings: TDextSettings;
    class function GetProvider: IDextJsonProvider; static;
  public
    /// <summary>
    ///   Sets the default settings to be used for all serialization/deserialization
    ///   operations that don't explicitly provide settings.
    /// </summary>
    class procedure SetDefaultSettings(const ASettings: TDextSettings); static;
    
    /// <summary>
    ///   Gets the current default settings.
    /// </summary>
    class function GetDefaultSettings: TDextSettings; static;
    /// <summary>
    ///   Gets or sets the JSON provider (driver) to be used.
    ///   Defaults to JsonDataObjects if not set.
    /// </summary>
    class property Provider: IDextJsonProvider read GetProvider write FProvider;
    
    /// <summary>
    ///   Deserializes a JSON string into a value of type T using default settings.
    /// </summary>
    class function Deserialize<T>(const AJson: string): T; overload; static;
    
    /// <summary>
    ///   Deserializes a JSON string into a value of type T using custom settings.
    /// </summary>
    class function Deserialize<T>(const AJson: string; const ASettings: TDextSettings): T; overload; static;
    
    /// <summary>
    ///   Deserializes a JSON string into a TValue based on the provided type info.
    /// </summary>
    class function Deserialize(AType: PTypeInfo; const AJson: string): TValue; overload; static;
    
    /// <summary>
    ///   Deserializes a JSON string into a TValue based on the provided type info with custom settings.
    /// </summary>
    class function Deserialize(AType: PTypeInfo; const AJson: string; const ASettings: TDextSettings): TValue; overload; static;
    
    /// <summary>
    ///   Deserializes a JSON string into a record TValue.
    /// </summary>
    class function DeserializeRecord(AType: PTypeInfo; const AJson: string): TValue; static;
    
    /// <summary>
    ///   Serializes a value of type T into a JSON string using default settings.
    /// </summary>
    class function Serialize<T>(const AValue: T): string; overload; static;
    
    /// <summary>
    ///   Serializes a value of type T into a JSON string using custom settings.
    /// </summary>
    class function Serialize<T>(const AValue: T; const ASettings: TDextSettings): string; overload; static;

    /// <summary>
    ///   Serializes a TValue into a JSON string using default settings.
    /// </summary>
    class function Serialize(const AValue: TValue): string; overload; static;
  end;

  /// <summary>
  ///   Internal serializer class responsible for the conversion logic.
  ///   Usually you should use TDextJson static methods instead.
  /// </summary>
  TDextSerializer = class
  private
    FSettings: TDextSettings;
  protected
    function GetFieldName(AField: TRttiField): string;
    function GetRecordName(ARttiType: TRttiType): string;
    function SerializeRecord(const AValue: TValue): IDextJsonObject;
    function SerializeObject(const AValue: TValue): IDextJsonObject;
    function ShouldSkipField(AField: TRttiField; const AValue: TValue): Boolean;

    function JsonToValue(AJson: IDextJsonObject; AType: PTypeInfo): TValue;
    function ValueToJson(const AValue: TValue): IDextJsonObject;
    
    function DeserializeArray(AJson: IDextJsonArray; AType: PTypeInfo): TValue;
    function DeserializeList(AJson: IDextJsonArray; AType: PTypeInfo): TValue;
    function SerializeArray(const AValue: TValue): IDextJsonArray;
    function SerializeList(const AValue: TValue): IDextJsonArray;
    
    function IsListType(AType: PTypeInfo): Boolean;
    function IsArrayType(AType: PTypeInfo): Boolean;
    function GetListElementType(AType: PTypeInfo): PTypeInfo;
    function GetArrayElementType(AType: PTypeInfo): PTypeInfo;
    function ApplyCaseStyle(const AName: string): string;
  public
    constructor Create(const ASettings: TDextSettings);
    function Deserialize<T>(const AJson: string): T;
    function DeserializeRecord(AJson: IDextJsonObject; AType: PTypeInfo): TValue;
    function DeserializeObject(AJson: IDextJsonObject; AType: PTypeInfo): TValue;
    function Serialize<T>(const AValue: T): string; overload;
    function Serialize(const AValue: TValue): string; overload;
  end;

  /// <summary>
  ///   Fluent JSON builder for programmatic JSON construction.
  ///   Example usage:
  ///     TJsonBuilder.Create
  ///       .Add('name', 'John')
  ///       .Add('age', 30)
  ///       .AddObject('address')
  ///         .Add('city', 'NYC')
  ///       .EndObject
  ///       .AddArray('tags')
  ///         .AddValue('one')
  ///         .AddValue('two')
  ///       .EndArray
  ///       .ToString
  /// </summary>
  TJsonBuilder = class
  private
    type
      TBuilderNode = class
        NodeType: (ntObject, ntArray);
        Parent: TBuilderNode;
        Key: string;
        JsonObj: IDextJsonObject;
        JsonArr: IDextJsonArray;
      end;
  private
    FRoot: TBuilderNode;
    FCurrent: TBuilderNode;
    FNodeStack: TList<TBuilderNode>;
    function GetCurrentObject: IDextJsonObject;
    function GetCurrentArray: IDextJsonArray;
  public
    constructor Create;
    destructor Destroy; override;
    
    /// <summary>Adds a string value to the current object.</summary>
    function Add(const AKey, AValue: string): TJsonBuilder; overload;
    
    /// <summary>Adds an integer value to the current object.</summary>
    function Add(const AKey: string; AValue: Integer): TJsonBuilder; overload;
    
    /// <summary>Adds a 64-bit integer value to the current object.</summary>
    function Add(const AKey: string; AValue: Int64): TJsonBuilder; overload;
    
    /// <summary>Adds a floating-point value to the current object.</summary>
    function Add(const AKey: string; AValue: Double): TJsonBuilder; overload;
    
    /// <summary>Adds a boolean value to the current object.</summary>
    function Add(const AKey: string; AValue: Boolean): TJsonBuilder; overload;
    
    /// <summary>Starts a nested object with the given key.</summary>
    function AddObject(const AKey: string): TJsonBuilder;
    
    /// <summary>Ends the current nested object and returns to the parent.</summary>
    function EndObject: TJsonBuilder;
    
    /// <summary>Starts a nested array with the given key.</summary>
    function AddArray(const AKey: string): TJsonBuilder;
    
    /// <summary>Ends the current nested array and returns to the parent.</summary>
    function EndArray: TJsonBuilder;
    
    /// <summary>Adds a string value to the current array.</summary>
    function AddValue(const AValue: string): TJsonBuilder; overload;
    
    /// <summary>Adds an integer value to the current array.</summary>
    function AddValue(AValue: Integer): TJsonBuilder; overload;
    
    /// <summary>Adds a boolean value to the current array.</summary>
    function AddValue(AValue: Boolean): TJsonBuilder; overload;
    
    /// <summary>Returns the built JSON as a compact string.</summary>
    function ToString: string; override;
    
    /// <summary>Returns the built JSON as an indented string.</summary>
    function ToIndentedString: string;
    
    /// <summary>Creates a new JSON builder instance.</summary>
    class function New: TJsonBuilder;
  end;

implementation

uses
  System.DateUtils,
  System.Variants,
  Dext.Core.Reflection,
  Dext.Core.DateUtils,
  Dext.Json.Driver.DextJsonDataObjects; // Default driver

const
  ValueField = 'value';

function FloatToJsonString(Value: Extended): string;
var
  FormatSettings: TFormatSettings;
begin
  FormatSettings := TFormatSettings.Create;
  FormatSettings.DecimalSeparator := '.';
  Result := FloatToStr(Value, FormatSettings);
end;

function JsonStringToFloat(const Value: string): Extended;
var
  FormatSettings: TFormatSettings;
  CleanValue: string;
begin
  FormatSettings := TFormatSettings.Create;
  FormatSettings.DecimalSeparator := '.';

  if Pos(',', Value) > 0 then
    CleanValue := StringReplace(Value, ',', '.', [rfReplaceAll])
  else
    CleanValue := Value;

  Result := StrToFloatDef(CleanValue, 0, FormatSettings);
end;

function IntToJsonString(Value: Int64): string;
begin
  Result := IntToStr(Value);
end;

function JsonStringToInt(const Value: string): Int64;
begin
  Result := StrToInt64Def(Value, 0);
end;

{ TJsonUtils }

class function TJsonUtils.ToCamelCase(const S: string): string;
begin
  if S.IsEmpty then Exit('');
  Result := S;
  Result[1] := Result[1].ToLower;
end;

class function TJsonUtils.ToPascalCase(const S: string): string;
begin
  if S.Length > 0 then
    Result := UpperCase(S[1]) + Copy(S, 2, MaxInt)
  else
    Result := S;
end;

class function TJsonUtils.ToSnakeCase(const S: string): string;
var
  SB: TStringBuilder;
  C: Char;
  i: Integer;
begin
  if S.IsEmpty then Exit('');
  
  SB := TStringBuilder.Create;
  try
    for i := 0 to S.Length - 1 do
    begin
      C := S.Chars[i];
      if C.IsUpper then
      begin
        if i > 0 then
          SB.Append('_');
        SB.Append(C.ToLower);
      end
      else
        SB.Append(C);
    end;
    Result := SB.ToString;
  finally
    SB.Free;
  end;
end;

class function TJsonUtils.ApplyCaseStyle(const S: string; Style: TDextCaseStyle): string;
begin
  case Style of
    TDextCaseStyle.CamelCase: Result := ToCamelCase(S);
    TDextCaseStyle.PascalCase: Result := ToPascalCase(S);
    TDextCaseStyle.SnakeCase: Result := ToSnakeCase(S);
  else
    Result := S;
  end;
end;

{ JsonNameAttribute }

constructor JsonNameAttribute.Create(const AName: string);
begin
  inherited Create;
  FName := AName;
end;

{ JsonFormatAttribute }

constructor JsonFormatAttribute.Create(const AFormat: string);
begin
  inherited Create;
  FFormat := AFormat;
end;

{ TDextSettings }

class function TDextSettings.Default: TDextSettings;
begin
  Result.Formatting := TDextFormatting.None;
  Result.IgnoreNullValues := False;
  Result.IgnoreDefaultValues := False;
  Result.DateFormat := 'yyyy-mm-dd"T"hh:nn:ss.zzz';
  Result.DateFormatStyle := TDextDateFormat.ISO8601;
  Result.CaseStyle := TDextCaseStyle.Unchanged;
  Result.EnumStyle := TDextEnumStyle.AsNumber;
  Result.CaseInsensitive := False;
end;

class function TDextSettings.Indented: TDextSettings;
begin
  Result := Default;
  Result.Formatting := TDextFormatting.Indented;
end;

function TDextSettings.WithCamelCase: TDextSettings;
begin
  Result := Self;
  Result.CaseStyle := TDextCaseStyle.CamelCase;
end;

function TDextSettings.WithPascalCase: TDextSettings;
begin
  Result := Self;
  Result.CaseStyle := TDextCaseStyle.PascalCase;
end;

function TDextSettings.WithSnakeCase: TDextSettings;
begin
  Result := Self;
  Result.CaseStyle := TDextCaseStyle.SnakeCase;
end;

function TDextSettings.WithUnixTimestamp: TDextSettings;
begin
  Result := Self;
  Result.DateFormatStyle := TDextDateFormat.UnixTimestamp;
  Result.DateFormat := '';
end;

function TDextSettings.WithEnumAsString: TDextSettings;
begin
  Result := Self;
  Result.EnumStyle := TDextEnumStyle.AsString;
end;

function TDextSettings.WithEnumAsNumber: TDextSettings;
begin
  Result := Self;
  Result.EnumStyle := TDextEnumStyle.AsNumber;
end;

function TDextSettings.WithIgnoreNullValues: TDextSettings;
begin
  Result := Self;
  Result.IgnoreNullValues := True;
end;

function TDextSettings.WithISODateFormat: TDextSettings;
begin
  Result := Self;
  Result.DateFormatStyle := TDextDateFormat.ISO8601;
  Result.DateFormat := 'yyyy-mm-dd"T"hh:nn:ss.zzz';
end;

function TDextSettings.WithCaseInsensitive: TDextSettings;
begin
  Result := Self;
  Result.CaseInsensitive := True;
end;

function TDextSettings.WithCustomDateFormat(const Format: string): TDextSettings;
begin
  Result := Self;
  Result.DateFormatStyle := TDextDateFormat.CustomFormat;
  Result.DateFormat := Format;
end;

{ TDextJson }

class function TDextJson.Deserialize<T>(const AJson: string): T;
begin
  Result := Deserialize<T>(AJson, GetDefaultSettings);
end;

class function TDextJson.Deserialize<T>(const AJson: string; const ASettings: TDextSettings): T;
var
  Serializer: TDextSerializer;
begin
  Serializer := TDextSerializer.Create(ASettings);
  try
    Result := Serializer.Deserialize<T>(AJson);
  finally
    Serializer.Free;
  end;
end;

class function TDextJson.Deserialize(AType: PTypeInfo; const AJson: string): TValue;
begin
  // Usar RTTI para chamar o método genérico apropriado
  case AType.Kind of
    tkInteger:
      Result := TValue.From<Integer>(Deserialize<Integer>(AJson));
    tkInt64:
      Result := TValue.From<Int64>(Deserialize<Int64>(AJson));
    tkFloat:
      if (AType = TypeInfo(TDateTime)) or (AType = TypeInfo(TDate)) or (AType = TypeInfo(TTime)) then
        Result := TValue.From<TDateTime>(Deserialize<TDateTime>(AJson))
      else
        Result := TValue.From<Double>(Deserialize<Double>(AJson));
    tkString, tkLString, tkWString, tkUString:
      Result := TValue.From<string>(Deserialize<string>(AJson));
    tkEnumeration:
      if AType = TypeInfo(Boolean) then
        Result := TValue.From<Boolean>(Deserialize<Boolean>(AJson))
      else
        Result := TValue.FromOrdinal(AType, Deserialize<Integer>(AJson));
    tkRecord:
      Result := DeserializeRecord(AType, AJson);
    tkClass:
      Result := Deserialize(AType, AJson, GetDefaultSettings);
    else
      raise EDextJsonException.CreateFmt('Unsupported type for deserialization: %s', [AType.NameFld.ToString]);
  end;
end;

class function TDextJson.Deserialize(AType: PTypeInfo; const AJson: string; const ASettings: TDextSettings): TValue;
var
  Serializer: TDextSerializer;
  JsonNode: IDextJsonNode;
begin
  Serializer := TDextSerializer.Create(ASettings);
  try
    JsonNode := TDextJson.Provider.Parse(AJson);
    
    if JsonNode.GetNodeType = jntObject then
    begin
      if AType.Kind = tkRecord then
        Result := Serializer.DeserializeRecord(JsonNode as IDextJsonObject, AType)
      else if AType.Kind = tkClass then
        Result := Serializer.DeserializeObject(JsonNode as IDextJsonObject, AType)
      else
        raise EDextJsonException.CreateFmt('Unsupported type for deserialization with settings: %s', [AType.NameFld.ToString]);
    end
    else
      raise EDextJsonException.Create('JSON root must be Object for record deserialization');
  finally
    Serializer.Free;
  end;
end;

class function TDextJson.DeserializeRecord(AType: PTypeInfo; const AJson: string): TValue;
var
  Serializer: TDextSerializer;
  JsonNode: IDextJsonNode;
begin
  Serializer := TDextSerializer.Create(GetDefaultSettings);
  try
    JsonNode := TDextJson.Provider.Parse(AJson);
    if JsonNode.GetNodeType = jntObject then
      Result := Serializer.DeserializeRecord(JsonNode as IDextJsonObject, AType)
    else
      raise EDextJsonException.Create('JSON root must be Object for record deserialization');
  finally
    Serializer.Free;
  end;
end;

class function TDextJson.Serialize<T>(const AValue: T): string;
begin
  Result := Serialize<T>(AValue, GetDefaultSettings);
end;

class function TDextJson.Serialize<T>(const AValue: T; const ASettings: TDextSettings): string;
var
  Serializer: TDextSerializer;
begin
  Serializer := TDextSerializer.Create(ASettings);
  try
    Result := Serializer.Serialize<T>(AValue);
  finally
    Serializer.Free;
  end;
end;

class function TDextJson.Serialize(const AValue: TValue): string;
var
  Serializer: TDextSerializer;
begin
  Serializer := TDextSerializer.Create(TDextSettings.Default);
  try
    Result := Serializer.Serialize(AValue);
  finally
    Serializer.Free;
  end;
end;

{ TDextSerializer }

constructor TDextSerializer.Create(const ASettings: TDextSettings);
begin
  inherited Create;
  FSettings := ASettings;
end;

function TDextSerializer.Deserialize<T>(const AJson: string): T;
var
  JsonNode: IDextJsonNode;
  Value: TValue;
begin
  JsonNode := TDextJson.Provider.Parse(AJson);
  try
    if JsonNode.GetNodeType = jntObject then
      Value := JsonToValue(JsonNode as IDextJsonObject, TypeInfo(T))
    else if JsonNode.GetNodeType = jntArray then
    begin
      // Handle root array deserialization
      if IsArrayType(TypeInfo(T)) then
        Value := DeserializeArray(JsonNode as IDextJsonArray, TypeInfo(T))
      else if IsListType(TypeInfo(T)) then
        Value := DeserializeList(JsonNode as IDextJsonArray, TypeInfo(T))
      else
        raise EDextJsonException.Create('JSON is an array but target type is not array/list');
    end
    else
      raise EDextJsonException.Create('JSON root must be Object or Array');
      
    Result := Value.AsType<T>;
  finally
    // Interface reference counting handles destruction
  end;
end;

function TDextSerializer.DeserializeObject(AJson: IDextJsonObject; AType: PTypeInfo): TValue;
var
  Context: TRttiContext;
  RttiType: TRttiType;
  Prop: TRttiProperty;
  PropName: string;
  ActualPropName: string;
  Found: Boolean;
  Instance: TObject;
  CreateMethod: TRttiMethod;
begin
  Context := TRttiContext.Create;
  try
    RttiType := Context.GetType(AType);
    
    // Create Instance
    CreateMethod := RttiType.GetMethod('Create');
    if (CreateMethod <> nil) and (Length(CreateMethod.GetParameters) = 0) then
    begin
      Result := CreateMethod.Invoke(RttiType.AsInstance.MetaclassType, []);
      Instance := Result.AsObject;
    end
    else
    begin
       // Try parameterless constructor if found by naming convention or common pattern?
       // For now, assume parameterless Create exists or use Activator if we had one.
       // Fallback: try to find any constructor?
       // Dext.Core.Activator uses a more robust approach, but here we stick to RTTI for now.
       raise EDextJsonException.CreateFmt('Cannot find parameterless constructor for %s', [AType.NameFld.ToString]);
    end;

    for Prop in RttiType.GetProperties do
    begin
      if (Prop.Visibility <> mvPublic) and (Prop.Visibility <> mvPublished) then
        Continue;

      if not Prop.IsWritable then
        Continue;

      PropName := ApplyCaseStyle(Prop.Name);
      
      // Check JsonName
      for var Attr in Prop.GetAttributes do
        if Attr is JsonNameAttribute then
        begin
          PropName := JsonNameAttribute(Attr).Name;
          Break;
        end;

      ActualPropName := PropName;
      Found := AJson.Contains(PropName);

      if (not Found) and FSettings.CaseInsensitive then
      begin
         // Simple scan
         var LowerProp := LowerCase(PropName);
         // This is inefficient but functional for now. 
         // Optimize later by iterating JSON keys once if performance needed.
         for var I := 0 to AJson.GetCount - 1 do
         begin
            var Key := AJson.GetName(I);
            if LowerCase(Key) = LowerProp then
            begin
               ActualPropName := Key;
               Found := True;
               Break;
            end;
         end;
      end;

      if not Found then Continue;

      // Deserialization Logic (Similar to DeserializeRecord but for Properties)
      var Node := AJson.GetNode(ActualPropName);
      if Node <> nil then
      begin
        var Val: TValue;
        case Node.GetNodeType of
          jntString: Val := TValue.From<string>(Node.AsString);
          jntNumber: 
            begin
              if (Prop.PropertyType.Handle = TypeInfo(Integer)) then
                Val := TValue.From<Integer>(Node.AsInteger)
              else if (Prop.PropertyType.Handle = TypeInfo(Int64)) then
                Val := TValue.From<Int64>(Node.AsInt64)
              else
                Val := TValue.From<Double>(Node.AsDouble);
            end;
          jntBoolean: Val := TValue.From<Boolean>(Node.AsBoolean);
          jntObject: 
            begin
              if (Prop.PropertyType.TypeKind = tkClass) then
                Val := DeserializeObject(Node as IDextJsonObject, Prop.PropertyType.Handle)
              else if (Prop.PropertyType.TypeKind = tkRecord) then
                Val := DeserializeRecord(Node as IDextJsonObject, Prop.PropertyType.Handle)
              else
                Val := TValue.Empty;
            end;
          jntArray: 
            begin
              if IsArrayType(Prop.PropertyType.Handle) then
                Val := DeserializeArray(Node as IDextJsonArray, Prop.PropertyType.Handle)
              else if IsListType(Prop.PropertyType.Handle) then
                Val := DeserializeList(Node as IDextJsonArray, Prop.PropertyType.Handle)
              else
                Val := TValue.Empty;
            end;
          else Val := TValue.Empty;
        end;
        
        if not Val.IsEmpty then
          TReflection.SetValue(Instance, Prop, Val);
      end;
    end;

  finally
    Context.Free;
  end;
end;

function TDextSerializer.DeserializeRecord(AJson: IDextJsonObject; AType: PTypeInfo): TValue;
var
  Context: TRttiContext;
  RttiType: TRttiType;
  Field: TRttiField;
  FieldName: string;
  ActualFieldName: string;
  FieldValue: TValue;
  Found: Boolean;
begin
  if AType = TypeInfo(TGUID) then
    Exit(TValue.From<TGUID>(StringToGUID(AJson.GetString(ValueField))));
  if AType = TypeInfo(TUUID) then
    Exit(TValue.From<TUUID>(TUUID.FromString(AJson.GetString(ValueField))));

  TValue.Make(nil, AType, Result);
  Context := TRttiContext.Create;
  try
    RttiType := Context.GetType(AType);

    for Field in RttiType.GetFields do
    begin
      if ShouldSkipField(Field, Result) then
        Continue;

      FieldName := GetFieldName(Field);
      ActualFieldName := FieldName;
      Found := AJson.Contains(FieldName);

      // Se não encontrou e CaseInsensitive está habilitado, buscar ignorando case
      if (not Found) and FSettings.CaseInsensitive then
      begin
        // Precisamos iterar pelas chaves do JSON para encontrar uma correspondência case-insensitive
        // Como não temos acesso direto às chaves via interface, vamos tentar variações comuns
        var LowerFieldName := LowerCase(FieldName);
        var UpperFieldName := UpperCase(FieldName);
        
        // Tentar lowercase
        if AJson.Contains(LowerFieldName) then
        begin
          ActualFieldName := LowerFieldName;
          Found := True;
        end
        // Tentar uppercase
        else if AJson.Contains(UpperFieldName) then
        begin
          ActualFieldName := UpperFieldName;
          Found := True;
        end
        // Tentar primeira letra minúscula (camelCase)
        else if Length(FieldName) > 0 then
        begin
          var CamelCaseName := LowerCase(FieldName[1]) + Copy(FieldName, 2, Length(FieldName) - 1);
          if AJson.Contains(CamelCaseName) then
          begin
            ActualFieldName := CamelCaseName;
            Found := True;
          end;
        end;
      end;

      if not Found then
        Continue;

      if Field.FieldType.Handle = TypeInfo(TGUID) then
      begin
        try
          var GuidStr := AJson.GetString(ActualFieldName).Trim;
          
          // StringToGUID requires braces, add if missing
          if (GuidStr <> '') and (not GuidStr.StartsWith('{')) then
            GuidStr := '{' + GuidStr + '}';
            
          FieldValue := TValue.From<TGUID>(StringToGUID(GuidStr));
        except
          FieldValue := TValue.From<TGUID>(TGUID.Empty);
        end;
        Field.SetValue(Result.GetReferenceToRawData, FieldValue);
        Continue;
      end;

      if Field.FieldType.Handle = TypeInfo(TUUID) then
      begin
        try
          FieldValue := TValue.From<TUUID>(TUUID.FromString(AJson.GetString(ActualFieldName)));
        except
          FieldValue := TValue.From<TUUID>(TUUID.Null);
        end;
        Field.SetValue(Result.GetReferenceToRawData, FieldValue);
        Continue;
      end;

      var Node := AJson.GetNode(ActualFieldName);
      if Node <> nil then
      begin
        var Val: TValue;
        case Node.GetNodeType of
          jntString: Val := TValue.From<string>(Node.AsString);
          jntNumber:
            begin
              if (Field.FieldType.Handle = TypeInfo(Integer)) then
                Val := TValue.From<Integer>(Node.AsInteger)
              else if (Field.FieldType.Handle = TypeInfo(Int64)) then
                Val := TValue.From<Int64>(Node.AsInt64)
              else
                Val := TValue.From<Double>(Node.AsDouble);
            end;
          jntBoolean: Val := TValue.From<Boolean>(Node.AsBoolean);
          jntObject: 
             begin
               if (Field.FieldType.TypeKind = tkClass) then
                 Val := DeserializeObject(Node as IDextJsonObject, Field.FieldType.Handle)
               else if (Field.FieldType.TypeKind = tkRecord) then
                 Val := DeserializeRecord(Node as IDextJsonObject, Field.FieldType.Handle)
               else
                 Val := TValue.Empty;
             end;
          jntArray: 
             begin
               if IsArrayType(Field.FieldType.Handle) then
                 Val := DeserializeArray(Node as IDextJsonArray, Field.FieldType.Handle)
               else if IsListType(Field.FieldType.Handle) then
                 Val := DeserializeList(Node as IDextJsonArray, Field.FieldType.Handle)
               else
                 Val := TValue.Empty;
             end;
          else Val := TValue.Empty;
        end;

        if not Val.IsEmpty then
          TReflection.SetValue(Result.GetReferenceToRawData, Field, Val);
      end;
    end;
  finally
    Context.Free;
  end;
end;

function TDextSerializer.GetFieldName(AField: TRttiField): string;
var
  Attribute: TCustomAttribute;
begin
  for Attribute in AField.GetAttributes do
  begin
    if Attribute is JsonNameAttribute then
      Exit(JsonNameAttribute(Attribute).Name);
  end;

  Result := ApplyCaseStyle(AField.Name);
end;

function TDextSerializer.GetRecordName(ARttiType: TRttiType): string;
var
  Attribute: TCustomAttribute;
begin
  for Attribute in ARttiType.GetAttributes do
  begin
    if Attribute is JsonNameAttribute then
      Exit(JsonNameAttribute(Attribute).Name);
  end;
  Result := '';
end;

function TDextSerializer.JsonToValue(AJson: IDextJsonObject; AType: PTypeInfo): TValue;
begin
  if AType.Kind = tkRecord then
  begin
    if AType = TypeInfo(TGUID) then
      Result := TValue.From<TGUID>(StringToGUID(AJson.GetString(ValueField)))
    else if AType = TypeInfo(TUUID) then
      Result := TValue.From<TUUID>(TUUID.FromString(AJson.GetString(ValueField)))
    else
      Result := DeserializeRecord(AJson, AType);
  end
  else if AType.Kind = tkClass then
  begin
    Result := DeserializeObject(AJson, AType);
  end
  else if IsArrayType(AType) then
  begin
    if AJson.Contains('value') then
    begin
      var Arr := AJson.GetArray('value');
      if Arr <> nil then
        Result := DeserializeArray(Arr, AType)
      else
        Result := TValue.Empty;
    end
    else
      Result := TValue.Empty;
  end
  else if IsListType(AType) then
  begin
    if AJson.Contains('value') then
    begin
      var Arr := AJson.GetArray('value');
      if Arr <> nil then
        Result := DeserializeList(Arr, AType)
      else
        Result := TValue.Empty;
    end
    else
      Result := TValue.Empty;
  end
  else if AJson.Contains(ValueField) then
  begin
    case AType.Kind of
      tkInteger:
        Result := TValue.From<Integer>(AJson.GetInteger(ValueField));

      tkInt64:
        Result := TValue.From<Int64>(AJson.GetInt64(ValueField));

      tkFloat:
        begin
          if (AType = TypeInfo(TDateTime)) or 
             (AType = TypeInfo(TDate)) or 
             (AType = TypeInfo(TTime)) then
          begin
            var DtStr := AJson.GetString(ValueField);
            var DtVal: TDateTime;
            if TryParseCommonDate(DtStr, DtVal) then
              Result := TValue.From<TDateTime>(DtVal)
            else
              Result := TValue.From<TDateTime>(0);
          end
          else
            Result := TValue.From<Double>(AJson.GetDouble(ValueField));
        end;

      tkString, tkLString, tkWString, tkUString:
        Result := TValue.From<string>(AJson.GetString(ValueField));

      tkEnumeration:
        begin
          if AType = TypeInfo(Boolean) then
            Result := TValue.From<Boolean>(AJson.GetBoolean(ValueField))
          else
            Result := TValue.FromOrdinal(AType, GetEnumValue(AType, AJson.GetString(ValueField)));
        end;

      else
        Result := TValue.Empty;
    end;
  end
  else
    Result := TValue.Empty;
end;

function TDextSerializer.Serialize<T>(const AValue: T): string;
var
  JsonNode: IDextJsonNode;
begin
  // Check if root is array or list
  if IsArrayType(TypeInfo(T)) then
    JsonNode := SerializeArray(TValue.From<T>(AValue))
  else if IsListType(TypeInfo(T)) then
    JsonNode := SerializeList(TValue.From<T>(AValue))
  else
    JsonNode := ValueToJson(TValue.From<T>(AValue));
    
  if FSettings.Formatting = TDextFormatting.Indented then
    Result := JsonNode.ToJson(True)
  else
    Result := JsonNode.ToJson(False);
end;

function TDextSerializer.Serialize(const AValue: TValue): string;
var
  JsonNode: IDextJsonNode;
begin
  // Check if root is array or list
  if IsArrayType(AValue.TypeInfo) then
    JsonNode := SerializeArray(AValue)
  else if IsListType(AValue.TypeInfo) then
    JsonNode := SerializeList(AValue)
  else
    JsonNode := ValueToJson(AValue);
    
  if FSettings.Formatting = TDextFormatting.Indented then
    Result := JsonNode.ToJson(True)
  else
    Result := JsonNode.ToJson(False);
end;

function TDextSerializer.SerializeRecord(const AValue: TValue): IDextJsonObject;
var
  Context: TRttiContext;
  Field: TRttiField;
  FieldName: string;
  FieldValue: TValue;
  RttiType: TRttiType;
  HasCustomFormat: Boolean;
  CustomFormat: string;
begin
  if AValue.TypeInfo = TypeInfo(TGUID) then
  begin
    Result := TDextJson.Provider.CreateObject;
    Result.SetString(ValueField, GUIDToString(AValue.AsType<TGUID>));
    Exit;
  end;

  if AValue.TypeInfo = TypeInfo(TUUID) then
  begin
    Result := TDextJson.Provider.CreateObject;
    Result.SetString(ValueField, AValue.AsType<TUUID>.ToString);
    Exit;
  end;

  Result := TDextJson.Provider.CreateObject;

  Context := TRttiContext.Create;
  try
    RttiType := Context.GetType(AValue.TypeInfo);
    for Field in RttiType.GetFields do
    begin
      if ShouldSkipField(Field, AValue) then
        Continue;

      FieldName := GetFieldName(Field);
      FieldValue := Field.GetValue(AValue.GetReferenceToRawData);

      // Smart Properties Support: Unwrap Prop<T>
      if (FieldValue.Kind = tkRecord) and (FieldValue.TypeInfo <> nil) and
         Context.GetType(FieldValue.TypeInfo).Name.StartsWith('Prop<') then
      begin
        var FValField := Context.GetType(FieldValue.TypeInfo).GetField('FValue');
        if FValField <> nil then
          FieldValue := FValField.GetValue(FieldValue.GetReferenceToRawData);
      end;

      HasCustomFormat := False;
      CustomFormat := '';

      for var Attr in Field.GetAttributes do
      begin
        if Attr is JsonFormatAttribute then
        begin
          HasCustomFormat := True;
          CustomFormat := JsonFormatAttribute(Attr).Format;
          Break;
        end;
      end;

      if (Field.FieldType.Handle = TypeInfo(TGUID)) or (FieldValue.TypeInfo = TypeInfo(TGUID)) then
      begin
        Result.SetString(FieldName, GUIDToString(FieldValue.AsType<TGUID>));
        Continue;
      end;

      if (Field.FieldType.Handle = TypeInfo(TUUID)) or (FieldValue.TypeInfo = TypeInfo(TUUID)) then
      begin
        Result.SetString(FieldName, FieldValue.AsType<TUUID>.ToString);
        Continue;
      end;

      if (FieldValue.TypeInfo.Kind = tkEnumeration) and
         (FieldValue.TypeInfo <> TypeInfo(Boolean)) then
      begin
        case FSettings.EnumStyle of
          TDextEnumStyle.AsString:
            Result.SetString(FieldName, GetEnumName(FieldValue.TypeInfo, FieldValue.AsOrdinal));
          TDextEnumStyle.AsNumber:
            Result.SetInteger(FieldName, FieldValue.AsOrdinal);
        end;
        Continue;
      end;

      case FieldValue.TypeInfo.Kind of
        tkInteger, tkInt64:
          begin
            var ForceString := False;
            for var Attr in Field.GetAttributes do
              if Attr is JsonStringAttribute then
                ForceString := True;

            if ForceString then
              Result.SetString(FieldName, IntToJsonString(FieldValue.AsInt64))
            else
              Result.SetInt64(FieldName, FieldValue.AsInt64);
          end;

        tkFloat:
          begin
          if (FieldValue.TypeInfo = TypeInfo(TDateTime)) or 
             (FieldValue.TypeInfo = TypeInfo(TDate)) or 
             (FieldValue.TypeInfo = TypeInfo(TTime)) then
            begin
              if HasCustomFormat then
                Result.SetString(FieldName, FormatDateTime(CustomFormat, FieldValue.AsExtended))
              else
                case FSettings.DateFormatStyle of
                  TDextDateFormat.ISO8601:
                    Result.SetString(FieldName, FormatDateTime(FSettings.DateFormat, FieldValue.AsExtended));
                  TDextDateFormat.UnixTimestamp:
                    Result.SetInt64(FieldName, DateTimeToUnix(FieldValue.AsExtended));
                  TDextDateFormat.CustomFormat:
                    Result.SetString(FieldName, FormatDateTime(FSettings.DateFormat, FieldValue.AsExtended));
                end;
            end
            else
            begin
              var ForceString := False;
              for var Attr in Field.GetAttributes do
                if Attr is JsonStringAttribute then
                  ForceString := True;

              if ForceString then
                Result.SetString(FieldName, FloatToJsonString(FieldValue.AsExtended))
              else
                Result.SetDouble(FieldName, FieldValue.AsExtended);
            end;
          end;

        tkString, tkLString, tkWString, tkUString:
          begin
            var ForceNumber := False;
            for var Attr in Field.GetAttributes do
              if Attr is JsonNumberAttribute then
                ForceNumber := True;

            if ForceNumber then
            begin
              var NumValue := JsonStringToFloat(FieldValue.AsString);
              Result.SetDouble(FieldName, NumValue);
            end
            else
            begin
              Result.SetString(FieldName, FieldValue.AsString);
            end;
          end;

        tkEnumeration:
          begin
            if FieldValue.TypeInfo = TypeInfo(Boolean) then
            begin
              var ForceString := False;
              for var Attr in Field.GetAttributes do
                if Attr is JsonStringAttribute then
                  ForceString := True;

              if ForceString then
                Result.SetString(FieldName, BoolToStr(FieldValue.AsBoolean, True))
              else
                Result.SetBoolean(FieldName, FieldValue.AsBoolean);
            end
            else
              Result.SetString(FieldName, GetEnumName(FieldValue.TypeInfo, FieldValue.AsOrdinal));
          end;

        tkRecord:
          begin
            var NestedRecord := SerializeRecord(FieldValue);
            Result.SetObject(FieldName, NestedRecord);
          end;
      end;
    end;
  finally
    Context.Free;
  end;
end;

function TDextSerializer.SerializeObject(const AValue: TValue): IDextJsonObject;
var
  Context: TRttiContext;
  Prop: TRttiProperty;
  PropName: string;
  PropValue: TValue;
  RttiType: TRttiType;
  Obj: TObject;
begin
  Result := TDextJson.Provider.CreateObject;

  if AValue.IsEmpty then
    Exit;

  Obj := AValue.AsObject;
  if Obj = nil then
    Exit;

  Context := TRttiContext.Create;
  try
    RttiType := Context.GetType(Obj.ClassType);
    
    for Prop in RttiType.GetProperties do
    begin
      // Skip non-public/published properties
      if (Prop.Visibility <> mvPublic) and (Prop.Visibility <> mvPublished) then
        Continue;
        
      // Skip if has JsonIgnore attribute
      var ShouldSkip := False;
      for var Attr in Prop.GetAttributes do
        if Attr is JsonIgnoreAttribute then
        begin
          ShouldSkip := True;
          Break;
        end;
      
      if ShouldSkip then
        Continue;

      PropName := ApplyCaseStyle(Prop.Name);
      
      // Check for JsonName attribute
      for var Attr in Prop.GetAttributes do
        if Attr is JsonNameAttribute then
        begin
          PropName := JsonNameAttribute(Attr).Name;
          Break;
        end;

      PropValue := Prop.GetValue(Obj);

      // Smart Properties Support: Unwrap Prop<T>
      if (PropValue.Kind = tkRecord) and (PropValue.TypeInfo <> nil) and
         Context.GetType(PropValue.TypeInfo).Name.StartsWith('Prop<') then
      begin
        var FValField := Context.GetType(PropValue.TypeInfo).GetField('FValue');
        if FValField <> nil then
          PropValue := FValField.GetValue(PropValue.GetReferenceToRawData);
      end;

      // Handle null/empty values
      if FSettings.IgnoreNullValues and PropValue.IsEmpty then
        Continue;

      // Serialize based on property type
      case PropValue.TypeInfo.Kind of
        tkInteger, tkInt64:
          Result.SetInt64(PropName, PropValue.AsInt64);

        tkFloat:
          begin
            if (PropValue.TypeInfo = TypeInfo(TDateTime)) or 
               (PropValue.TypeInfo = TypeInfo(TDate)) or 
               (PropValue.TypeInfo = TypeInfo(TTime)) then
              Result.SetString(PropName, FormatDateTime(FSettings.DateFormat, PropValue.AsExtended))
            else
              Result.SetDouble(PropName, PropValue.AsExtended);
          end;

        tkString, tkLString, tkWString, tkUString:
          Result.SetString(PropName, PropValue.AsString);

        tkEnumeration:
          begin
            if PropValue.TypeInfo = TypeInfo(Boolean) then
              Result.SetBoolean(PropName, PropValue.AsBoolean)
            else
              Result.SetString(PropName, GetEnumName(PropValue.TypeInfo, PropValue.AsOrdinal));
          end;

        tkRecord:
          begin
            if PropValue.TypeInfo = TypeInfo(TGUID) then
              Result.SetString(PropName, GUIDToString(PropValue.AsType<TGUID>))
            else if PropValue.TypeInfo = TypeInfo(TUUID) then
              Result.SetString(PropName, PropValue.AsType<TUUID>.ToString)
            else
            begin
              var NestedRecord := SerializeRecord(PropValue);
              Result.SetObject(PropName, NestedRecord);
            end;
          end;

        tkClass:
          begin
            if PropValue.AsObject = nil then
              Result.SetNull(PropName)
            else if IsListType(PropValue.TypeInfo) then
              Result.SetArray(PropName, SerializeList(PropValue))
            else
              Result.SetObject(PropName, SerializeObject(PropValue));
          end;

        tkDynArray:
          Result.SetArray(PropName, SerializeArray(PropValue));
      end;
    end;
  finally
    Context.Free;
  end;
end;

function TDextSerializer.ShouldSkipField(AField: TRttiField; const AValue: TValue): Boolean;
var
  Attribute: TCustomAttribute;
  FieldValue: TValue;
begin
  for Attribute in AField.GetAttributes do
  begin
    if Attribute is JsonIgnoreAttribute then
      Exit(True);
  end;

  if not AValue.IsEmpty then
    FieldValue := AField.GetValue(AValue.GetReferenceToRawData)
  else
    FieldValue := TValue.Empty;

  if FSettings.IgnoreNullValues and FieldValue.IsEmpty then
    Exit(True);

  if FSettings.IgnoreDefaultValues then
  begin
    case FieldValue.Kind of
      tkInteger: if FieldValue.AsInteger = 0 then Exit(True);
      tkInt64: if FieldValue.AsInt64 = 0 then Exit(True);
      tkFloat: if FieldValue.AsExtended = 0 then Exit(True);
      tkUString, tkString, tkWString, tkLString:
        if FieldValue.AsString = '' then Exit(True);
      tkEnumeration:
        if FieldValue.TypeInfo = TypeInfo(Boolean) then
        begin
          if not FieldValue.AsBoolean then Exit(True)
        end
        else if FieldValue.AsOrdinal = 0 then Exit(True);
    end;
  end;

  Result := (AField.Visibility <> mvPublic) or
            (AField.FieldType = nil) or
            (AField.Name.StartsWith('$'));
end;

function TDextSerializer.ValueToJson(const AValue: TValue): IDextJsonObject;
begin
  Result := TDextJson.Provider.CreateObject;

  if AValue.IsEmpty then
    Exit;

  case AValue.TypeInfo.Kind of
    tkInteger, tkInt64:
      Result.SetInt64(ValueField, AValue.AsInt64);

    tkFloat:
      begin
        if AValue.TypeInfo = TypeInfo(TDateTime) then
          Result.SetString(ValueField, FormatDateTime(FSettings.DateFormat, AValue.AsExtended))
        else
          Result.SetDouble(ValueField, AValue.AsExtended);
      end;

    tkString, tkLString, tkWString, tkUString:
      Result.SetString(ValueField, AValue.AsString);

    tkEnumeration:
      begin
        if AValue.TypeInfo = TypeInfo(Boolean) then
          Result.SetBoolean(ValueField, AValue.AsBoolean)
        else
          Result.SetString(ValueField, GetEnumName(AValue.TypeInfo, AValue.AsOrdinal));
      end;

    tkRecord:
      begin
        if AValue.TypeInfo = TypeInfo(TGUID) then
          Result.SetString(ValueField, GUIDToString(AValue.AsType<TGUID>))
        else if AValue.TypeInfo = TypeInfo(TUUID) then
          Result.SetString(ValueField, AValue.AsType<TUUID>.ToString)
        else
          // Replace result with serialized record
          // Note: ValueToJson returns Object. If SerializeRecord returns Object, we are good.
          Result := SerializeRecord(AValue);
      end;

    // Array handling in ValueToJson is tricky because return type is IDextJsonObject
    // But SerializeArray returns IDextJsonArray.
    // We should probably change ValueToJson to return IDextJsonNode or handle arrays separately.
    // For now, let's wrap in "value" field if it's array, or change logic.
    // The original code did: Result.A[ValueField] := SerializeArray(AValue);
    tkDynArray:
      begin
        Result.SetArray(ValueField, SerializeArray(AValue));
      end;

    tkClass:
      begin
        // Distinguish between lists and regular objects
        if IsListType(AValue.TypeInfo) then
          Result.SetArray(ValueField, SerializeList(AValue))
        else
          Result := SerializeObject(AValue);
      end;
  end;
end;

class function TDextJson.GetProvider: IDextJsonProvider;
begin
  if FProvider = nil then
    FProvider := TJsonDataObjectsProvider.Create;
  Result := FProvider;
end;

class procedure TDextJson.SetDefaultSettings(const ASettings: TDextSettings);
begin
  FDefaultSettings := ASettings;
end;

class function TDextJson.GetDefaultSettings: TDextSettings;
begin
  // If not explicitly set, return the default
  if (FDefaultSettings.DateFormat = '') and not FDefaultSettings.CaseInsensitive then
    Result := TDextSettings.Default
  else
    Result := FDefaultSettings;
end;

function TDextSerializer.IsArrayType(AType: PTypeInfo): Boolean;
begin
  Result := (AType.Kind = tkDynArray);
end;

function TDextSerializer.IsListType(AType: PTypeInfo): Boolean;
begin
  Result := ((AType.Kind = tkClass) or (AType.Kind = tkInterface)) and
            ((Pos('System.Generics.Collections', string(AType.TypeData^.UnitName)) > 0) or
             (Pos('Dext.Collections', string(AType.TypeData^.UnitName)) > 0));
end;

function TDextSerializer.GetArrayElementType(AType: PTypeInfo): PTypeInfo;
begin
  Result := AType.TypeData^.DynArrElType^;
end;

function TDextSerializer.GetListElementType(AType: PTypeInfo): PTypeInfo;
var
  Context: TRttiContext;
  RttiType: TRttiType;
  Method: TRttiMethod;
  Prop: TRttiProperty;
begin
  Context := TRttiContext.Create;
  try
    RttiType := Context.GetType(AType);
    
    // Try GetItem method (indexer getter)
    Method := RttiType.GetMethod('GetItem');
    if Assigned(Method) and (Method.MethodKind = mkFunction) and (Length(Method.GetParameters) = 1) then
      Exit(Method.ReturnType.Handle);

    // Try Add method (collection addition)
    for Method in RttiType.GetMethods do
    begin
      if (Method.Name = 'Add') and (Length(Method.GetParameters) = 1) then
      begin
        Exit(Method.GetParameters[0].ParamType.Handle);
      end;
    end;
    
    // Try Items property
    Prop := RttiType.GetProperty('Items');
    if Assigned(Prop) then
      Exit(Prop.PropertyType.Handle);

    Result := nil;
  finally
    Context.Free;
  end;
end;

function TDextSerializer.DeserializeArray(AJson: IDextJsonArray; AType: PTypeInfo): TValue;
var
  ElementType: PTypeInfo;
  DynArray: Pointer;
  I: Integer;
  ElementValue: TValue;
  P: PByte;
  Count: NativeInt;
begin
  ElementType := GetArrayElementType(AType);
  DynArray := nil;
  Count := AJson.GetCount;
  DynArraySetLength(DynArray, AType, 1, @Count); // AJson.Count -> GetCount

  try
    for I := 0 to AJson.GetCount - 1 do
    begin
      case ElementType.Kind of
        tkInteger:
          ElementValue := TValue.From<Integer>(AJson.GetInteger(I));
        tkInt64:
          ElementValue := TValue.From<Int64>(AJson.GetInt64(I));
        tkFloat:
          if ElementType = TypeInfo(TDateTime) then
            ElementValue := TValue.From<TDateTime>(ISO8601ToDate(AJson.GetString(I)))
          else
            ElementValue := TValue.From<Double>(AJson.GetDouble(I));
        tkString, tkLString, tkWString, tkUString:
          ElementValue := TValue.From<string>(AJson.GetString(I));
        tkEnumeration:
          if ElementType = TypeInfo(Boolean) then
            ElementValue := TValue.From<Boolean>(AJson.GetBoolean(I))
          else
            ElementValue := TValue.FromOrdinal(ElementType, GetEnumValue(ElementType, AJson.GetString(I)));
        tkRecord:
          begin
            if ElementType = TypeInfo(TGUID) then
              ElementValue := TValue.From<TGUID>(StringToGUID(AJson.GetString(I)))
            else if ElementType = TypeInfo(TUUID) then
              ElementValue := TValue.From<TUUID>(TUUID.FromString(AJson.GetString(I)))
            else
            begin
              var Node := AJson.GetNode(I);
              if (Node <> nil) and (Node.GetNodeType = jntObject) then
                ElementValue := DeserializeRecord(Node as IDextJsonObject, ElementType)
              else
                ElementValue := TValue.Empty;
            end;
          end;
        tkClass:
          begin
            var Node := AJson.GetNode(I);
            if (Node <> nil) and (Node.GetNodeType = jntObject) then
               ElementValue := DeserializeObject(Node as IDextJsonObject, ElementType)
            else
               ElementValue := TValue.Empty;
          end;
      else
        ElementValue := TValue.Empty;
      end;

      if not ElementValue.IsEmpty then
      begin
        P := PByte(DynArray) + (I * ElementType.TypeData^.elSize);
        Move(ElementValue.GetReferenceToRawData^, P^, ElementType.TypeData^.elSize);
      end;
    end;

    TValue.Make(@DynArray, AType, Result);
    // The local DynArray pointer holds a reference. TValue.Make creates another (increments refcount).
    // We must clear the local reference so that only the TValue holds usage.
    DynArrayClear(DynArray, AType);
  except
    if DynArray <> nil then
      DynArrayClear(DynArray, AType);
    raise;
  end;
end;

function TDextSerializer.DeserializeList(AJson: IDextJsonArray; AType: PTypeInfo): TValue;
var
  ElementType: PTypeInfo;
  List: TObject;
  I: Integer;
  ElementValue: TValue;
  AddMethod: TRttiMethod;
  Context: TRttiContext;
begin
  Context := TRttiContext.Create;
  try
    var RttiType := Context.GetType(AType);
    var CreateMethod: TRttiMethod := nil;

    for var Method in RttiType.GetMethods do
      if Method.IsConstructor and (Length(Method.GetParameters) = 0) then
      begin
        CreateMethod := Method;
        Break;
      end;

    if CreateMethod = nil then
      CreateMethod := RttiType.GetMethod('Create');

    if CreateMethod = nil then
      raise EDextJsonException.CreateFmt('Cannot find a suitable constructor for %s', [AType.NameFld.ToString]);

    Result := CreateMethod.Invoke(AType^.TypeData^.ClassType, []);
    List := Result.AsObject;

    AddMethod := Context.GetType(AType).GetMethod('Add');
    ElementType := GetListElementType(AType);

    for I := 0 to AJson.GetCount - 1 do
    begin
      var Node := AJson.GetNode(I);
      if (Node <> nil) and (Node.GetNodeType = jntObject) then
      begin
        if ElementType.Kind = tkClass then
          ElementValue := DeserializeObject(Node as IDextJsonObject, ElementType)
        else
          ElementValue := DeserializeRecord(Node as IDextJsonObject, ElementType);
      end
      else
      begin
        case ElementType.Kind of
          tkInteger: ElementValue := TValue.From<Integer>(AJson.GetInteger(I));
          tkInt64: ElementValue := TValue.From<Int64>(AJson.GetInt64(I));
          tkFloat: ElementValue := TValue.From<Double>(AJson.GetDouble(I));
          tkUString, tkString, tkWString, tkLString:
            ElementValue := TValue.From<string>(AJson.GetString(I));
          tkEnumeration:
            if ElementType = TypeInfo(Boolean) then
              ElementValue := TValue.From<Boolean>(AJson.GetBoolean(I))
            else
              ElementValue := TValue.Empty;
          tkRecord:
            if ElementType = TypeInfo(TGUID) then
              ElementValue := TValue.From<TGUID>(StringToGUID(AJson.GetString(I)))
            else if ElementType = TypeInfo(TUUID) then
              ElementValue := TValue.From<TUUID>(TUUID.FromString(AJson.GetString(I)))
            else
              ElementValue := TValue.Empty;
          else
            ElementValue := TValue.Empty;
        end;
      end;

      if not ElementValue.IsEmpty then
        AddMethod.Invoke(List, [ElementValue]);
    end;
  finally
    Context.Free;
  end;
end;

function TDextSerializer.SerializeArray(const AValue: TValue): IDextJsonArray;
var
  ElementType: PTypeInfo;
  I, Count: Integer;
  ElementValue: TValue;
begin
  Result := TDextJson.Provider.CreateArray;

  ElementType := GetArrayElementType(AValue.TypeInfo);
  Count := AValue.GetArrayLength;

  for I := 0 to Count - 1 do
  begin
    ElementValue := AValue.GetArrayElement(I);

    case ElementType.Kind of
      tkInteger:
        Result.Add(ElementValue.AsInteger);
      tkInt64:
        Result.Add(ElementValue.AsInt64);
      tkFloat:
        if ElementType = TypeInfo(TDateTime) then
          Result.Add(FormatDateTime(FSettings.DateFormat, ElementValue.AsExtended))
        else
          Result.Add(ElementValue.AsExtended);
      tkString, tkLString, tkWString, tkUString:
        Result.Add(ElementValue.AsString);
      tkEnumeration:
        if ElementType = TypeInfo(Boolean) then
          Result.Add(ElementValue.AsBoolean)
        else
          Result.Add(GetEnumName(ElementType, ElementValue.AsOrdinal));
      tkRecord:
        if ElementType = TypeInfo(TGUID) then
          Result.Add(GUIDToString(ElementValue.AsType<TGUID>))
        else if ElementType = TypeInfo(TUUID) then
          Result.Add(ElementValue.AsType<TUUID>.ToString)
        else
          Result.Add(SerializeRecord(ElementValue));
      tkClass:
        begin
          if ElementValue.AsObject = nil then
            Result.AddNull
          else
            Result.Add(SerializeObject(ElementValue));
        end;
      tkDynArray:
        Result.Add(SerializeArray(ElementValue));
    else
      Result.AddNull;
    end;
  end;
end;

function TDextSerializer.SerializeList(const AValue: TValue): IDextJsonArray;
var
  Count: Integer;
  I: Integer;
  ElementValue: TValue;
  Context: TRttiContext;
  RttiType: TRttiType;
  IntfValue: IInterface;
  CountMethod: TRttiMethod;
  GetItemMethod: TRttiMethod;
begin
  Result := TDextJson.Provider.CreateArray;
  
  if AValue.IsEmpty then Exit;

  Context := TRttiContext.Create;
  try
    RttiType := Context.GetType(AValue.TypeInfo);
    
    // For interfaces, we need to get the interface value
    if AValue.Kind = tkInterface then
    begin
      IntfValue := AValue.AsInterface;
      if IntfValue = nil then Exit;
      
      // Try to get Count via GetCount method instead of property
      CountMethod := RttiType.GetMethod('GetCount');
      if not Assigned(CountMethod) then Exit;
      
      Count := CountMethod.Invoke(AValue, []).AsInteger;
      
      // Get the GetItem method
      GetItemMethod := RttiType.GetMethod('GetItem');
      if not Assigned(GetItemMethod) then Exit;
      
      for I := 0 to Count - 1 do
      begin
        ElementValue := GetItemMethod.Invoke(AValue, [I]);
        
        if ElementValue.IsEmpty then
        begin
          Result.AddNull;
          Continue;
        end;

        case ElementValue.TypeInfo.Kind of
          tkRecord:
            if ElementValue.TypeInfo = TypeInfo(TGUID) then
              Result.Add(GUIDToString(ElementValue.AsType<TGUID>))
            else if ElementValue.TypeInfo = TypeInfo(TUUID) then
              Result.Add(ElementValue.AsType<TUUID>.ToString)
            else
              Result.Add(SerializeRecord(ElementValue));
          tkClass:
            begin
              if ElementValue.AsObject = nil then
                Result.AddNull
              else
                Result.Add(SerializeObject(ElementValue));
            end;
          tkDynArray:
            Result.Add(SerializeArray(ElementValue));
          tkInteger, tkInt64:
            Result.Add(ElementValue.AsInt64);
          tkFloat:
            Result.Add(ElementValue.AsExtended);
          tkString, tkLString, tkWString, tkUString:
            Result.Add(ElementValue.AsString);
          tkEnumeration:
            if ElementValue.TypeInfo = TypeInfo(Boolean) then
              Result.Add(ElementValue.AsBoolean)
            else
              Result.Add(GetEnumName(ElementValue.TypeInfo, ElementValue.AsOrdinal));
        else
          Result.AddNull;
        end;
      end;
    end
    else if AValue.Kind = tkClass then
    begin
      // For classes, use the original RTTI approach
      var Instance := AValue.AsObject;
      if Instance = nil then Exit;
      
      var CountProp := RttiType.GetProperty('Count');
      if not Assigned(CountProp) then Exit;
      
      Count := CountProp.GetValue(Instance).AsInteger;
      
      GetItemMethod := RttiType.GetMethod('GetItem');
      if not Assigned(GetItemMethod) then
        GetItemMethod := RttiType.GetMethod('Items');
      
      if Assigned(GetItemMethod) then
      begin
        for I := 0 to Count - 1 do
        begin
          ElementValue := GetItemMethod.Invoke(Instance, [I]);

          case ElementValue.TypeInfo.Kind of
            tkRecord:
              if ElementValue.TypeInfo = TypeInfo(TGUID) then
                Result.Add(GUIDToString(ElementValue.AsType<TGUID>))
              else if ElementValue.TypeInfo = TypeInfo(TUUID) then
                Result.Add(ElementValue.AsType<TUUID>.ToString)
              else
                Result.Add(SerializeRecord(ElementValue));
            tkClass:
              begin
                if ElementValue.AsObject = nil then
                  Result.AddNull
                else
                  Result.Add(SerializeObject(ElementValue));
              end;
            tkDynArray:
              Result.Add(SerializeArray(ElementValue));
            tkInteger, tkInt64:
              Result.Add(ElementValue.AsInt64);
            tkFloat:
              Result.Add(ElementValue.AsExtended);
            tkString, tkLString, tkWString, tkUString:
              Result.Add(ElementValue.AsString);
            tkEnumeration:
              if ElementValue.TypeInfo = TypeInfo(Boolean) then
                Result.Add(ElementValue.AsBoolean)
              else
                Result.Add(GetEnumName(ElementValue.TypeInfo, ElementValue.AsOrdinal));
          else
            Result.AddNull;
          end;
        end;
      end;
    end;
  finally
    Context.Free;
  end;
end;

function TDextSerializer.ApplyCaseStyle(const AName: string): string;
begin
  Result := TJsonUtils.ApplyCaseStyle(AName, FSettings.CaseStyle);
end;

{ TJsonBuilder }

constructor TJsonBuilder.Create;
begin
  inherited Create;
  FNodeStack := TList<TBuilderNode>.Create;
  
  FRoot := TBuilderNode.Create;
  FRoot.NodeType := ntObject;
  FRoot.JsonObj := TDextJson.Provider.CreateObject;
  FRoot.Parent := nil;
  
  FCurrent := FRoot;
  FNodeStack.Add(FRoot);
end;

destructor TJsonBuilder.Destroy;
var
  Node: TBuilderNode;
begin
  for Node in FNodeStack do
    Node.Free;
  FNodeStack.Free;
  inherited;
end;

class function TJsonBuilder.New: TJsonBuilder;
begin
  Result := TJsonBuilder.Create;
end;

function TJsonBuilder.GetCurrentObject: IDextJsonObject;
begin
  if FCurrent.NodeType = ntObject then
    Result := FCurrent.JsonObj
  else
    raise EDextJsonException.Create('Current context is not an object');
end;

function TJsonBuilder.GetCurrentArray: IDextJsonArray;
begin
  if FCurrent.NodeType = ntArray then
    Result := FCurrent.JsonArr
  else
    raise EDextJsonException.Create('Current context is not an array');
end;

function TJsonBuilder.Add(const AKey, AValue: string): TJsonBuilder;
begin
  GetCurrentObject.SetString(AKey, AValue);
  Result := Self;
end;

function TJsonBuilder.Add(const AKey: string; AValue: Integer): TJsonBuilder;
begin
  GetCurrentObject.SetInteger(AKey, AValue);
  Result := Self;
end;

function TJsonBuilder.Add(const AKey: string; AValue: Int64): TJsonBuilder;
begin
  GetCurrentObject.SetInt64(AKey, AValue);
  Result := Self;
end;

function TJsonBuilder.Add(const AKey: string; AValue: Double): TJsonBuilder;
begin
  GetCurrentObject.SetDouble(AKey, AValue);
  Result := Self;
end;

function TJsonBuilder.Add(const AKey: string; AValue: Boolean): TJsonBuilder;
begin
  GetCurrentObject.SetBoolean(AKey, AValue);
  Result := Self;
end;

function TJsonBuilder.AddObject(const AKey: string): TJsonBuilder;
var
  NewNode: TBuilderNode;
  NewObj: IDextJsonObject;
begin
  NewObj := TDextJson.Provider.CreateObject;
  GetCurrentObject.SetObject(AKey, NewObj);
  
  NewNode := TBuilderNode.Create;
  NewNode.NodeType := ntObject;
  NewNode.JsonObj := NewObj;
  NewNode.Parent := FCurrent;
  NewNode.Key := AKey;
  
  FNodeStack.Add(NewNode);
  FCurrent := NewNode;
  Result := Self;
end;

function TJsonBuilder.EndObject: TJsonBuilder;
begin
  if FCurrent.Parent = nil then
    raise EDextJsonException.Create('Cannot end root object');
    
  FCurrent := FCurrent.Parent;
  Result := Self;
end;

function TJsonBuilder.AddArray(const AKey: string): TJsonBuilder;
var
  NewNode: TBuilderNode;
  NewArr: IDextJsonArray;
begin
  NewArr := TDextJson.Provider.CreateArray;
  GetCurrentObject.SetArray(AKey, NewArr);
  
  NewNode := TBuilderNode.Create;
  NewNode.NodeType := ntArray;
  NewNode.JsonArr := NewArr;
  NewNode.Parent := FCurrent;
  NewNode.Key := AKey;
  
  FNodeStack.Add(NewNode);
  FCurrent := NewNode;
  Result := Self;
end;

function TJsonBuilder.EndArray: TJsonBuilder;
begin
  if FCurrent.Parent = nil then
    raise EDextJsonException.Create('Cannot end root array');
    
  FCurrent := FCurrent.Parent;
  Result := Self;
end;

function TJsonBuilder.AddValue(const AValue: string): TJsonBuilder;
begin
  GetCurrentArray.Add(AValue);
  Result := Self;
end;

function TJsonBuilder.AddValue(AValue: Integer): TJsonBuilder;
begin
  GetCurrentArray.Add(AValue);
  Result := Self;
end;

function TJsonBuilder.AddValue(AValue: Boolean): TJsonBuilder;
begin
  GetCurrentArray.Add(AValue);
  Result := Self;
end;

function TJsonBuilder.ToString: string;
begin
  Result := FRoot.JsonObj.ToJson(False);
end;

function TJsonBuilder.ToIndentedString: string;
begin
  Result := FRoot.JsonObj.ToJson(True);
end;

end.
